<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.11.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>BMSNode: BMS Node Packet Specification</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">BMSNode
							</div>
							<div id="projectbrief">BMS Node Cell Monitoring Firmware</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2_users_2joe_2_documents_2_projects_2tronics_2emiata_2bms_2bmsnode_2bmsnode__firmware_2doc_2packet.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">BMS Node Packet Specification</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md11"></a>
Features</h1>
<ul>
<li>multi-drop, daisy-chained serial bus</li>
<li>destination addressing</li>
<li>broadcast capability</li>
<li>controller initiated transactions</li>
<li>8-bit CRC</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Hardware Considerations</h1>
<p>The serial hardware design uses a daisy-chained multi-drop bus. Each node is optically isolated and automatically propagates the serial data to the next node. The MCU serial RX and TX lines are shared which means that the MCU is listening most of the time, and only transmits in response to receiving a packet that it addressed to that node.</p>
<p>The serial driver in the MCU must keep the TX signal as an input (or high-Z) except when it is transmitting. It must also make sure that the entire last byte has been transmitted before turning off the TX signal.</p>
<p>There is no hardware mechanism to prevent bus collisions. The design relies on the command/response format and that no node transmits unless commanded and only the controller (commanding host) issues commands. The controller software must ensure enough time between commands for responses to finish.</p>
<p>The serial hardware design does incur a rise-time/fall-time error that accumulates with each node which limits the total number of nodes that can be chained together. That number is not characterized here.</p>
<p>The present firmware is using 9600 for the data rate.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Future Changes</h1>
<p>The packet format presented below has been in use for a while. The flags field was included in the format in anticipation of the need for additional signaling. However during the firmware development there has not appeared a need for any additional flags.</p>
<p>As a future optimization, the reply flag could be combined with the address or command fields, saving a byte.</p>
<p>Another possible change, would be to change the preamble byte to another value that would make it easier to perform autobaud. The current preamble byte is a square wave which makes it possible to measure a single bit time using a timer. But that requires adding bit measuring timer code to the firmware. There are other autobaud techniques that use carefully chosen values that appear as different valid values depending on the baud rate.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Packet Format</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Byte   </th><th class="markdownTableHeadNone">Field   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-2   </td><td class="markdownTableBodyNone">Preamble   </td><td class="markdownTableBodyNone">One or more bytes used to wake up devices and establish sync    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-1   </td><td class="markdownTableBodyNone">Sync   </td><td class="markdownTableBodyNone">Sync byte to indicate start of packet    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Flags   </td><td class="markdownTableBodyNone">TBD flags to indicate features of packet: broadcast, reply, etc    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Address   </td><td class="markdownTableBodyNone">Node address for packet    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Command   </td><td class="markdownTableBodyNone">command ID    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Length   </td><td class="markdownTableBodyNone">payload length in bytes (can be 0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4+   </td><td class="markdownTableBodyNone">Payload   </td><td class="markdownTableBodyNone">variable payload contents (can be none)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">CRC   </td><td class="markdownTableBodyNone">8-bit CRC   </td></tr>
</table>
<h2>Preamble</h2>
<p><b>Value: 0x55</b></p>
<p>Preamble bytes are used to "wake up" the nodes on the bus in preparation to receive a packet. There must be at least one preamble byte and there is no upper limit. Each node simply ignores preamble bytes.</p>
<p>A string of preamble bytes can be used to reset nodes parsing state machine. <em>With the current limit of 12 data bytes</em>, along with a single CRC byte, 13 preamble bytes should always cause the parser to return to the searching state.</p>
<h2>Sync</h2>
<p><b>Value: 0xF0</b></p>
<p>The sync byte marks the start of a packet. There must always be at least one preamble byte followed by a single sync byte to mark the start of a packet.</p>
<h2>Flags</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bit   </th><th class="markdownTableHeadNone">Flag   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">reply   </td><td class="markdownTableBodyNone">0=command to node, 1=reply from node    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">init   </td><td class="markdownTableBodyNone">0=normal, 1=init mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5:0   </td><td class="markdownTableBodyNone">res   </td><td class="markdownTableBodyNone">reserved   </td></tr>
</table>
<p>The function of the init flag is TBD.</p>
<p>It is possible that the flags field could be combined with the length field to eliminate one byte of header.</p>
<h2>Address</h2>
<p>This is the node address. Node addresses are assigned using the <code>ADDR</code> command. Only one un-addressed node can be on a serial bus at one time. So nodes should be added to the bus one at a time and get immediate address assignment using the <code>ADDR</code> command. Or, they can be assigned when the board is tested or provisioned by the board test or provisioning utility.</p>
<p>At the moment, addresses 1-254 are valid node addresses while 0 and 255 are reserved. Address 254 is being used for testing.</p>
<p>For packets from the controller to a node, the controller sets the address field to the destination node. Each node knows its own address and only responds to packets with a matching address.</p>
<p>For response packets back to the controller, the address field is the address of the responding node.</p>
<h2>Command</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ID   </th><th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">reserved   </td><td class="markdownTableBodyNone">not used    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">PING   </td><td class="markdownTableBodyNone">bus detection and aliveness    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">DFU   </td><td class="markdownTableBodyNone">enter device firmware update mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">UID   </td><td class="markdownTableBodyNone">discover board unique ID (see notes in command spec)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">ADDR   </td><td class="markdownTableBodyNone">set board bus address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">ADCRAW   </td><td class="markdownTableBodyNone">read raw ADC sample data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">STATUS   </td><td class="markdownTableBodyNone">read BMS node status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">SHUNTON   </td><td class="markdownTableBodyNone">turn on shunting    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">SHUNTOFF   </td><td class="markdownTableBodyNone">turn off shunting    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">SETPARM   </td><td class="markdownTableBodyNone">set configuration parameter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">GETPARM   </td><td class="markdownTableBodyNone">get configuration parameter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">TESTMODE   </td><td class="markdownTableBodyNone">place hardware into various test modes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12   </td><td class="markdownTableBodyNone">FACTORY   </td><td class="markdownTableBodyNone">restore parameters to default   </td></tr>
</table>
<p>See [Command Specification](command) for command details.</p>
<h2>Length</h2>
<p>The number of payload bytes, which can be 0 and up to 12 (TBD). If the length is 0, then there is no payload and it is a command-only packet.</p>
<h2>CRC</h2>
<p>An 8-bit CRC over the header and data bytes. It does not include preamble or sync bytes. An 8-bit format is chosen to keep packet size as small as possible.</p>
<p>The AVR toolchain runtime library provides an 8-bit CRC function called "crc8_ccitt" and that is used for BMS Node packet check field.</p>
<p><a href="https://www.nongnu.org/avr-libc/user-manual/group__util__crc.html#gab27eaaef6d7fd096bd7d57bf3f9ba083">https://www.nongnu.org/avr-libc/user-manual/group__util__crc.html#gab27eaaef6d7fd096bd7d57bf3f9ba083</a></p>
<p>A Python implementation is provided at the end of this document.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Parser State Machine</h1>
<p>TODO: add state diagram</p>
<h2>Searching</h2>
<p>The parser is searching for preamble bytes. It remains in this state until a preamble byte is received.</p>
<h2>Sync</h2>
<p>The parser is waiting for a sync byte. It will remain in this state as long as it continues to receive preamble bytes. If it receives a sync byte it then begins receiving a header. If it receives any value that is not sync or preamble then it returns to <em>Searching</em>.</p>
<h2>Header</h2>
<p>In the header state the parser is reading in header bytes. The the extent possible it validates header bytes as they are received. If any header byte is found to not be valid, the parser returns to <em>Searching</em>. Once the correct number of header bytes are received, the parser goes to <em>Payload</em> or <em>Check</em> states, depending on whether there is any payload.</p>
<h2>Payload</h2>
<p>In the paylod state, the parser is storing incoming bytes into the payload area of the packet buffer. It will store the number of bytes as data according to the header length field. There is no validation of payload bytes. The parser will only leave this state after receiving the correct number of payload bytes.</p>
<p>The parser can be forced out of this state by sending enough preamble bytes to complete the payload state.</p>
<h2>Check</h2>
<p>In this state the parser inteprets the next byte received as the CRC byte. It compares the value to a crc-8 value it accumulated as header and payload bytes were received. If they match, then the packet is valid. If they do not match then the packet is not valid and the incoming buffer is discarded and the parser returns to <em>Searching</em>.</p>
<h2>False Detection</h2>
<p>It is possible that the parser may be in the searching state while a packet is in progress on the bus. The parser header or payload data may appear to be the start of a valid packet. For example the payload may contain a preamble byte followed by a sync byte.</p>
<p>If this happens, the parser may incorrectly detect the start of a packet and start to receive header and possible payload data. This will be detected and the parser return to the search state if any header byte is detected as not valid. And in the worst case it appears to have received a valid header, then it will attempt to receive a number of data bytes and then finally the CRC will fail.</p>
<p>The probability of this occuring is considered small enough for our purposes to not be a concern. In the worst case the parser falsely thinks it has a header for the maximum number of payload bytes. In this case the parser can always be reset by sending the number of preamble bytes to match the maximum payload size plus 1 (for the CRC byte). In the current design this is 13 preamble bytes.</p>
<p>In operation, this should be handled as follows: if any node stops responding, the controller should send out at least 13 preamble bytes to reset the parser of all nodes on the bus.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
CRC Python Implementation</h1>
<p>Following is a python implementation of the same CRC function used by the packet processor. The <code>pktbytes</code> argument is bytes-like.</p>
<div class="fragment"><div class="line">def crc8_ccitt(pktbytes):</div>
<div class="line">    crc = 0</div>
<div class="line"> </div>
<div class="line">    for inbyte in pktbytes:</div>
<div class="line"> </div>
<div class="line">        databyte = crc ^ inbyte</div>
<div class="line"> </div>
<div class="line">        for idx in range(8):</div>
<div class="line">            if (databyte &amp; 0x80) != 0:</div>
<div class="line">                databyte &lt;&lt;= 1</div>
<div class="line">                databyte ^= 0x07</div>
<div class="line">            else:</div>
<div class="line">                databyte &lt;&lt;= 1</div>
<div class="line"> </div>
<div class="line">        crc = databyte &amp; 0xFF</div>
<div class="line">    return crc</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="footer">
					Generated on Wed Jan 22 2025 15:43:06 for BMSNode by <a href="http://www.doxygen.org/index.html">
					<img class="footer" src="doxygen.png" alt="doxygen"
                     onerror="this.onerror=null;this.src='doxygen.svg';"/></a> 1.11.0.
					Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
