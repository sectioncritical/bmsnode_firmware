<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.11.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>BMSNode: BMSNode Design Notes</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">BMSNode
							</div>
							<div id="projectbrief">BMS Node Cell Monitoring Firmware</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2_users_2joe_2_documents_2_projects_2tronics_2emiata_2bms_2bmsnode_2bmsnode__firmware_2doc_2design.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">BMSNode Design Notes</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is an informal design document to collect various notes about the BMSNode firmware design.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Other Documents</h1>
<ul>
<li><a class="el" href="md__2_users_2joe_2_documents_2_projects_2tronics_2emiata_2bms_2bmsnode_2bmsnode__firmware_2doc_2requirements.html">Project requirements</a></li>
<li><a class="el" href="md__2_users_2joe_2_documents_2_projects_2tronics_2emiata_2bms_2bmsnode_2bmsnode__firmware_2doc_2packet.html">Packet Protocol Specification</a></li>
<li><a class="el" href="md__2_users_2joe_2_documents_2_projects_2tronics_2emiata_2bms_2bmsnode_2bmsnode__firmware_2doc_2command.html">Command Specification</a></li>
<li><a class="el" href="md__2_users_2joe_2_documents_2_projects_2tronics_2emiata_2bms_2bmsnode_2bmsnode__firmware_2doc_2release-process.html">Release Process</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Tools and Development Environment</h1>
<p>The firmware is written in C and compiled using <b>avr-gcc</b>. Toolchain binaries are available from <a href="https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers">Microchip</a> and other places. You can also get the AVR toolchain as a plugin for <a href="https://platformio.org">platformio</a>.</p>
<p>Makefiles are used extensively wherever automation scripting is useful. Most non-embedded tooling is written in Python (3). Look in Makefiles first to see how to use various automation scripts. Also look at README files for sometimes useful information.</p>
<p>The development environment is assumed to be POSIX-like with normal development tools and bash shell (other shells may work). Almost all steps are done using command line tools.</p>
<p>Firmware is unit tested (in the host environment) using <a href="https://github.com/catchorg/Catch2">Catch2</a> and <a href="https://github.com/meekrosoft/fff">Fake Function Framework</a>. During unit test code coverage data is generated using the compiler built-in profiling and reports generated using <a href="https://gcovr.com/en/stable/">gcovr</a>. Code quality checking is performed using <a href="http://cppcheck.sourceforge.net">cppcheck</a>. See the Makefile in the repository <code>./test</code> subdirectory for available test operations.</p>
<p><a href="https://docs.gitlab.com/ee/ci/">GitLab CI</a> is used for continuous integration. Each time the repository is pushed to GitLab, the firmware is built and all automated tests are run, documentation is built, and preliminary release notes and release package is generated. Tagged releases are also made using GitLab CI and assisted by <a href="https://juhani.gitlab.io/go-semrel-gitlab/">go-semrel-gitlab</a>. A purpose-built docker image is used for CI automation. See the <code>./build/docker</code> subdirectory for details.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Execution Environment</h1>
<p>BMSNode firmware runs on an ATTiny1614 AVR microcontroller (as of v3 boards, prior versions used ATTiny841).</p>
<ul>
<li>10 MHz</li>
<li>16k program storage (flash)</li>
<li>2048 bytes RAM (data, heap, stack)</li>
<li>256 bytes EEPROM-like persistent storage</li>
</ul>
<p>The firmware makes use of the following peripherals:</p>
<ul>
<li>UART</li>
<li>hardware timer</li>
<li>watchdog timer</li>
<li>external voltage reference</li>
<li>ADC</li>
<li>GPIO</li>
</ul>
<p>The firmware makes use of a boot loader to allow field updates of the application. The boot loader is a variant of optiboot_x. See the subdirectory <code>./build/bootloader/optiboot_x</code> for details. The optiboot_x boot loader uses a little less than 512 bytes at this time and occupies the two lowest pages in flash, in the "boot" section.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Design Overview</h1>
<p>The firmware follow the typical embedded application pattern of using a main loop to run the various processes and a simple state machine to track the device functional states.</p>
<p>When the program starts it initializes the hardware execution environment (hardware peripheral registers) and various module components (software init). After that it enters a forever loop.</p>
<p>There are some interrupt handlers to perform some processing in interrupt context. These are mainly the serial UART and a hardware tick timer.</p>
<p>At the top of the loop, several modules <code>_run()</code> function is called. These are non-blocking calls that allow the module to perform unit(s) of processing as non-interrupt code.</p>
<p>The background processes (called from the top of main loop) can generate events such as timer timeouts, incoming commands, and sensor thresholds (such low voltage or high temperature). Any events that are generated are then passed to a state machine.</p>
<p>The rest of the main loop is implemented as a state machine with handler code for each state.</p>
<h2>Low Level Processing</h2>
<h3>Hardware Timer</h3>
<p>Hardware timer TCB0 is used to generate a 1 millisecond tick using an interrupt. The interrupt handler increments a 16-bit counter, providing the ability to count up to 65535 milliseconds. However, to implement 16-bit timer comparison math, the maximum timeout for the 1-millisecond timer is 32767 milliseconds. The hardware timer code is part of the <code>tmr</code> module (see below).</p>
<h3>Serial Receive and Transmit</h3>
<p>Hardware interrupts are used for receiving and transmitting serial data. The MCU UART peripheral support half duplex in hardware and uses a shared pin. The firmware is usually listening in receive (RX) mode. It will transmit when there is a command requiring a response.</p>
<p>The receive interrupt receives any incoming bytes and passes the byte to the packet parser (see <code>pkt</code> module). The packet parser assembles packets from the incoming serial data.</p>
<p>The transmit ready interrupt is used to transmit a buffer of data (containing a response packet). When a response is needed the response packet is assembled into a transmit buffer, then RX is disabled and TX enabled. The TX interrupt copies a byte at a time to the serial output until all the bytes are transmitted.</p>
<p>The transmit ready interrupt occurs whenever the UART peripheral can buffer another byte. Once a byte has been written to the UART, it takes some amount of time for the bytes to be shifted out on the serial bus.</p>
<p>There is a second transmit interrupt, the TX empty which indicates all the data has been shifted out. This interrupt is used to turn off the serial TX signal output and re-enable the serial input. This is needed because the TX and RX share the same signal, and when the MCU is not transmitting serial, the serial signal must be disabled so that data can be received on the RX signal.</p>
<p>See the <code>ser</code> module.</p>
<h2>Modules</h2>
<p>Here is a brief description of the major code modules. For more details see the <a href="modules.html">API documentation</a>. Consider this a very high-level view. The generated docs are always likely to be more up to date and more detailed.</p>
<h3>ADC</h3>
<p><a href="group__adc.html">ADC Module Docs</a></p>
<p>Provides an API to perform power-up and power down of the ADC peripheral. In order to achieve the lowest power consumption while sleeping, the peripheral must be turned off. It also provides functions to sample all the ADC channels and to convert the raw data into engineering units.</p>
<h3>Configuration</h3>
<p><a href="group__cfg.html">Configuration Module Docs</a></p>
<p>This module manages storage of node-specific persistent data. It holds the node bus ID and all the configuration parameters. The data is stored in a block structure and uses a CRC to improve data integrity. If the stored data is corrupted then a set of default parameters are used.</p>
<p>Functions are provided to load and store the configuration data between RAM and EEPROM. There are also get and set functions for retrieving and modifying specific parameters.</p>
<p>In normal operation, when the configuration is not being modified, the parameters are retrieved from EEPROM, and validated, and the stored in a global structure in RAM for direct access by the other modules.</p>
<h3>Command</h3>
<p><a href="group__cmd.html">Command Module Docs</a></p>
<p>This module provides a command processor that is called from the main loop. The processor checks for any new, complete packets that are received. If a new packet is available, it checks for a valid command addressed to this node. If a complete, valid command is received, it dispatches a command handler for that command.</p>
<p>The remainder of this module implement handlers for each command.</p>
<h3>LED</h3>
<p><a href="group__led.html">LED Module Docs</a></p>
<p>This module provides a simple abstraction for the LEDs on the board. There are functions to turn the LEDs on or off, or to blink at a certain rate. It uses the timer module to perform the blinking operation. There is a <code>_run()</code> function that must be called from the main loop that manages the LED blink timers and turns the LEDs on and off as needed.</p>
<h3>List</h3>
<p><a href="group__list.html">List Module Docs</a></p>
<p>A simple linked list utility for use by other parts of the code.</p>
<h3>Packet</h3>
<p><a href="group__pkt.html">Packet Module Docs</a></p>
<p>This module provides the packet parser. It is called once for each received byte. It watches for the start of the packet and collects all the incoming bytes in a buffer until the full packet is received. At the end if validates the packet CRC. If a complete packet is received and validated, it becomes available to the command processor through an API. The packet parser does not take any action on its own. If any error is detected at any point in receiving packet data, then the parser is reset to search for the next start of packet.</p>
<p>The module uses a simple (not malloc/free) buffer allocation mechanism to hold and free the parsed packet data.</p>
<h3>Serial</h3>
<p><a href="group__ser.html">Serial Module Docs</a></p>
<p>This module implements a driver for the UART peripheral. It uses interrupts to manage receiving and sending serial data.</p>
<p>When data is to be transmitted a function is used to pass the data to the. serial module. The data is copied into a small ring buffer where it is then sent a byte at a time using the TX interrupt.</p>
<p>On the receive side, as data bytes are received in the RX interrupt, they are passed to the packet parser where they are assembled into a packet. In this case the packet module manages the buffering (there is no serial receive buffer apart from the packet buffering in the packet module).</p>
<h3>Shunt</h3>
<p><a href="group__shunt.html">Shunt Module Docs</a></p>
<p>The shunt module implement an algorithm for turning the resistive load shunt on or off according to voltage an temperature. The shunting is turned on when the voltage rises above a certain threshold (a configuration parameter) and turned off when below a certain threshold. While shunting is on, the temperature is monitored and if it goes above a temperature limit, the shunting is modulated to keep the board from exceeding the maximum allowable temperature.</p>
<p>The module provided a <code>_run()</code> function that must be called from the main loop to keep the shunt algorithm running.</p>
<p>The shunt behavior can be enabled or disabled (by command).</p>
<h3>Testmode</h3>
<p><a href="group__testmode.html">Testmode Module Docs</a></p>
<p>This module provides some functions to place the node into various test modes, mainly to exercise the IO hardware on the board for test purposes.</p>
<h3>Thermistor</h3>
<p><a href="group__therm.html">Thermistor Module Docs</a></p>
<p>This module provides a pre-computed lookup table for ADC count to temperature conversion for the on-board thermistor. It is called from the ADC module to convert the ADC to temperature in C.</p>
<h3>Timer</h3>
<p><a href="group__tmr.html">Timer Module Docs</a></p>
<p>This module provides several functions to support timing needs of the BMSNode firmware. First, it maintains an interrupt driven tick timer. This is used as the basis for all other timing in the system.</p>
<p>There is a simple timer API that allows setting a timeout up to 32 seconds in the future, and for then checking the status of the timeout.</p>
<p>There is a second set of functions that provides a way to set a future timer that is added to a list maintained by the timer module. Then there is a process function that is called by the main loop. The process function will return an expired timer. The timer module will manage the list and add and remove timers from the list as appropriate, and also provide for periodic or one-shot timeouts.</p>
<h3>Main</h3>
<p>The main module provides the starting entry point for the application. It performs the hardware initialization, and calls any necessary init functions for the various modules.</p>
<p>It then sets up a forever loop that runs any non-interrupt background processes (the <code>_run()</code> functions) and checks for events like incoming commands or expired timers. It then runs a state machine and passes events to the current running state.</p>
<p>The state machine implements a handler for each state that performs the processing and transitions for that state.</p>
<h2>State Machine</h2>
<p>The main function of the firmware is implemented as a state machine. Refer to the diagram and state descriptios below.</p>
<p><img src="img/state-diagram.svg" alt="State Diagram" style="pointer-events: none;" class="inline"/></p>
<h3>State Transitions</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">PS   </th><th class="markdownTableHeadNone">NS   </th><th class="markdownTableHeadNone">Transition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">init   </td><td class="markdownTableBodyNone">powerup   </td><td class="markdownTableBodyNone">unconditional    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">powerup   </td><td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">1 seconds delay    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">dfu   </td><td class="markdownTableBodyNone">DFU command    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dfu   </td><td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">8 second timeout    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">shunt   </td><td class="markdownTableBodyNone">SHUNT command    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">shunt   </td><td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">shunt mode ends (by command or timeout)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">testmode   </td><td class="markdownTableBodyNone">TESTMODE command    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">testmode   </td><td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">testmode ends (by command or timeout)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">sleep   </td><td class="markdownTableBodyNone">inactivity for 1 second    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sleep   </td><td class="markdownTableBodyNone">idle   </td><td class="markdownTableBodyNone">serial bus activity   </td></tr>
</table>
<h3>State Descriptions</h3>
<h4>hwstart</h4>
<p>Initializes the hardware and software modules, and powers up the ADC. Enabled interrupts.</p>
<h4>powerup</h4>
<p>Blinks LED rapidly for 1 second. Allows time for init and powerup.</p>
<h4>idle</h4>
<p>This is the main state used to transition to other states. In this state, the MCU is awake but there is no activity. In this state, certain command cause transition to other command-specific states. If there is no serial activity for 1 second, then it will transition to the sleep state.</p>
<h4>dfu</h4>
<p>This state is used to ensure the node stays awake for an extended duration (8 seconds) in order to give time for a DFU (boot load) opertion to begin on the bus.</p>
<p>This state is a legacy of the older board design that required each node to be a serial repeater. This state can be/should be removed.</p>
<h4>shunt</h4>
<p>This state is used to run the shunt mode process. In this mode the MCU always stays awake. It remains in this state until the shunt mode ends either by command, or because the shunt mode is idle for a timeout period.</p>
<h4>testmode</h4>
<p>This state is used to run a test mode (not used in normal operation). The MCU remains awake until test mode ends.</p>
<h4>sleep</h4>
<p>This state is used to manage the MCU entyr and exit from the lowest power sleep mode. It disables and powers down peripherals and places the hardware in a safe configuration. It then puts the MCU into sleep mode. When the MCU is in sleep mode, it is not executing any code and is consuming minimal power.</p>
<p>When there is serial activity on the bus, the MCU will exit sleep mode and the code will resume execution. When this happens, the sleep state code will re-power and configure the peripherals and return to the idle state. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="footer">
					Generated on Wed Jan 22 2025 15:43:06 for BMSNode by <a href="http://www.doxygen.org/index.html">
					<img class="footer" src="doxygen.png" alt="doxygen"
                     onerror="this.onerror=null;this.src='doxygen.svg';"/></a> 1.11.0.
					Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
